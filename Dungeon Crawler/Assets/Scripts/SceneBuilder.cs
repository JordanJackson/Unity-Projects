using System;
using System.Collections.Generic;
using UnityEngine;

// uses the map generated by MapGenerator to populate the scene with
// level prefabs, scenery prefabs as well as player and enemy entities
public class SceneBuilder : MonoBehaviour
{
	// level geometry parameters
	public float floorScaleFactor = 0.1f;
	public float scaleFactor = 1f;
	public float enemiesPerRoom = 1f;
	// level, scenery, entity prefabs
	public GameObject wallPrefab;
	public GameObject pillarPrefab;
	public GameObject stoneFloorPrefab;
	public GameObject ceilingPrefab;
	public GameObject wallTorch;
	public GameObject brazierPrefab;
	public GameObject player;
	public GameObject[] enemyPrefabs;
	// transform for organizing scene objects into cleaner hierarchy
	public Transform sceneryContainer;
	// parameters for finetuning the placement of scenery (torches, braziers, etc.)
	public float brazierOffset;
	public float torchPillarOffset;
	public float torchWallOffset;
	public float torchHeight;
	public float torchScale;
	public float corridorTorchChance;
	public float roomTorchChance;
	// maintain list of wall objects(prefabs)
	private List<GameObject> wallList;
	// reference to map generated by MapGenerator
	Map map;

	// given map from MapGenerator, populate the scene
	public void BuildScene(Map m)
	{
		map = m;
		// if rebuilding level, clear wallList and delete all prefabs in scene
		if (this.wallList != null)
		{
			this.ClearLevel();
		}
		this.wallList = new List<GameObject>();
		// place floor
		GameObject floorObject = (GameObject)UnityEngine.Object.Instantiate(this.stoneFloorPrefab, new Vector3(map.sizeX / 2 *scaleFactor, 0.0f, map.sizeY / 2*scaleFactor), Quaternion.identity);
		floorObject.transform.localScale = new Vector3((float)map.sizeX * this.floorScaleFactor * this.scaleFactor, 1f, (float)map.sizeY * this.floorScaleFactor * this.scaleFactor);
		floorObject.GetComponent<Renderer>().material.mainTextureScale = new Vector2((float)map.sizeX, (float)map.sizeY);
		floorObject.isStatic = true;
		// place ceiling
		GameObject ceilingObject = (GameObject)UnityEngine.Object.Instantiate(this.ceilingPrefab, new Vector3(map.sizeX / 2 *scaleFactor, 3f * this.scaleFactor, map.sizeY / 2 *scaleFactor), Quaternion.identity);
		ceilingObject.transform.localScale = new Vector3((float)map.sizeX * this.floorScaleFactor * this.scaleFactor, -1f, (float)map.sizeY * this.floorScaleFactor * this.scaleFactor);
		ceilingObject.GetComponent<Renderer>().material.mainTextureScale = new Vector2((float)map.sizeX, (float)map.sizeY);
		floorObject.transform.parent = sceneryContainer.FindChild ("LevelObjects");
		ceilingObject.transform.parent = sceneryContainer.FindChild ("LevelObjects");
		// populate scene by tiletype
		for (int i = 0; i < map.sizeX; i++)
		{
			for (int j = 0; j < map.sizeY; j++)
			{
				if (map.tiles[i,j].type == Tile.TileType.Wall)
				{
					this.PlaceWall(i, j);
				}
				if (map.tiles[i,j].type == Tile.TileType.Connection)
				{
				 	this.PlaceTorch(i, j);
				}
				if (map.tiles[i,j].type == Tile.TileType.Corridor && UnityEngine.Random.Range(0f, 1f) <= this.corridorTorchChance)
				{
					this.PlaceTorch(i, j);
				}
				if (map.tiles[i,j].type == Tile.TileType.Room && UnityEngine.Random.Range(0f, 1f) <= this.roomTorchChance)
				{
					this.PlaceTorch(i, j);
				}
			}
		}
		this.OrganizeHierarchy();
		if (this.scaleFactor != 1f)
		{
			for (int k = 0; k < this.wallList.Count; k++)
			{
				Vector3 localScale = this.wallList[k].transform.localScale * this.scaleFactor;
				this.wallList[k].transform.localScale = localScale;
				this.wallList[k].isStatic = true;
			}
		}
		PlaceBraziers ();
	}

	// instantiate wall at x,y. The prefab used depends on the type and # of
	// adjacent tiles
	private void PlaceWall(int x, int y)
	{
		if (this.NumberOfNeighboursOfType(x, y, Tile.TileType.Connection) >= 1)
		{
			this.wallList.Add((GameObject)UnityEngine.Object.Instantiate(this.pillarPrefab, new Vector3((float)(x) * this.scaleFactor, 1.5f * this.scaleFactor, (float)(y) * this.scaleFactor), Quaternion.identity));
		}
		else if (this.NumberOfNeighboursOfType(x, y, Tile.TileType.Corridor) >= 3)
		{
			this.wallList.Add((GameObject)UnityEngine.Object.Instantiate(this.pillarPrefab, new Vector3((float)(x) * this.scaleFactor, 1.5f * this.scaleFactor, (float)(y) * this.scaleFactor), Quaternion.identity));
		}
		else if (this.NumberOfNeighboursOfType(x, y, Tile.TileType.Wall) >= 3)
		{
			this.wallList.Add((GameObject)UnityEngine.Object.Instantiate(this.pillarPrefab, new Vector3((float)(x) * this.scaleFactor, 1.5f * this.scaleFactor, (float)(y) * this.scaleFactor), Quaternion.identity));
		}
		else if (this.LeftNeighbour(x, y, Tile.TileType.Wall) && this.RightNeighbour(x, y, Tile.TileType.Wall))
		{
			this.wallList.Add((GameObject)UnityEngine.Object.Instantiate(this.wallPrefab, new Vector3((float)(x) * this.scaleFactor, 1.5f * this.scaleFactor, (float)(y) * this.scaleFactor), Quaternion.identity));
		}
		else if (this.UpperNeighbour(x, y, Tile.TileType.Wall) && this.BottomNeighbour(x, y, Tile.TileType.Wall))
		{
			this.wallList.Add((GameObject)UnityEngine.Object.Instantiate(this.wallPrefab, new Vector3((float)(x) * this.scaleFactor, 1.5f * this.scaleFactor, (float)(y) * this.scaleFactor), Quaternion.Euler(0f, 90f, 0f)));
		}
		else
		{
			this.wallList.Add((GameObject)UnityEngine.Object.Instantiate(this.pillarPrefab, new Vector3((float)(x) * this.scaleFactor, 1.5f * this.scaleFactor, (float)(y) * this.scaleFactor), Quaternion.identity));
		}
	}

	// helper function, returns the # of tiles of type adjacent to x,y
	private int NumberOfNeighboursOfType(int x, int y, Tile.TileType type)
	{
		int num = 0;
		if (this.LeftNeighbour(x, y, type))
		{
			num++;
		}
		if (this.RightNeighbour(x, y, type))
		{
			num++;
		}
		if (this.UpperNeighbour(x, y, type))
		{
			num++;
		}
		if (this.BottomNeighbour(x, y, type))
		{
			num++;
		}
		return num;
	}
	// returns true if tile left of x,y is of type type
	private bool LeftNeighbour(int x, int y, Tile.TileType type)
	{
		return x - 1 >= 0 && map.tiles[x - 1, y].type == type;
	}
	// returns true if tile right of x,y is of type type
	private bool RightNeighbour(int x, int y, Tile.TileType type)
	{
		return x + 1 < map.sizeX && map.tiles[x + 1, y].type == type;
	}
	// returns true if tile above x,y is of type type
	private bool UpperNeighbour(int x, int y, Tile.TileType type)
	{
		return y - 1 >= 0 && map.tiles[x, y - 1].type == type;
	}
	// returns true if tile below x,y is of type type
	private bool BottomNeighbour(int x, int y, Tile.TileType type)
	{
		return y + 1 < map.sizeY && map.tiles[x, y + 1].type == type;
	}

	// given position x, y determine rotation and position of torch 
	// depending on location of walls adjacent to position x,y
	private void PlaceTorch(int x, int y)
	{
		if (map.tiles[x + 1, y].type == Tile.TileType.Wall)
		{
			float offset = GetTorchOffset(x+1, y);
			GameObject gameObject = (GameObject)Instantiate(wallTorch, new Vector3(((float)(x) + offset) * this.scaleFactor, torchHeight * this.scaleFactor, (float)(y) * this.scaleFactor), Quaternion.Euler(new Vector3(0f, 270f, 0f)));
			gameObject.transform.localScale *= this.scaleFactor * this.torchScale;
			gameObject.transform.parent = sceneryContainer.FindChild ("Torches");
		}
		else if (map.tiles[x - 1, y].type == Tile.TileType.Wall)
		{
			float offset = GetTorchOffset(x-1, y);
			GameObject gameObject = (GameObject)Instantiate(wallTorch, new Vector3(((float)(x) - offset) * this.scaleFactor, torchHeight * this.scaleFactor, (float)(y) * this.scaleFactor), Quaternion.Euler(new Vector3(0f, 90f, 0f)));
			gameObject.transform.localScale *= this.scaleFactor * this.torchScale;
			gameObject.transform.parent = sceneryContainer.FindChild ("Torches");
		}
		else if (map.tiles[x, y + 1].type == Tile.TileType.Wall)
		{
			float offset = GetTorchOffset(x, y+1);
			GameObject gameObject = (GameObject)Instantiate(wallTorch, new Vector3((float)(x) * this.scaleFactor, torchHeight * this.scaleFactor, ((float)(y) + offset) * this.scaleFactor), Quaternion.Euler(new Vector3(0f, 180f, 0f)));
			gameObject.transform.localScale *= this.scaleFactor * this.torchScale;
			gameObject.transform.parent = sceneryContainer.FindChild ("Torches");
		}
		else if (map.tiles[x, y - 1].type == Tile.TileType.Wall)
		{
			float offset = GetTorchOffset(x, y-1);
			GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(wallTorch, new Vector3((float)(x) * this.scaleFactor, torchHeight * this.scaleFactor, ((float)(y) - offset) * this.scaleFactor), Quaternion.Euler(new Vector3(0f, 0f, 0f)));
			gameObject.transform.localScale *= this.scaleFactor * this.torchScale;
			gameObject.transform.parent = sceneryContainer.FindChild ("Torches");
		}
	}

	// By number of neighbours of type, we know which prefab was placed. Thus we can
	// determine the appropriate offset
	private float GetTorchOffset(int x, int y) {
		if (this.NumberOfNeighboursOfType(x, y, Tile.TileType.Connection) >= 1)
		{
			return torchPillarOffset;
		}
		else if (this.NumberOfNeighboursOfType(x, y, Tile.TileType.Corridor) >= 3)
		{
			return torchPillarOffset;
		}
		else if (this.NumberOfNeighboursOfType(x, y, Tile.TileType.Wall) >= 3)
		{
			return torchPillarOffset;
		}
		else if (this.LeftNeighbour(x, y, Tile.TileType.Wall) && this.RightNeighbour(x, y, Tile.TileType.Wall))
		{
			return torchWallOffset;
		}
		else if (this.UpperNeighbour(x, y, Tile.TileType.Wall) && this.BottomNeighbour(x, y, Tile.TileType.Wall))
		{
			return torchWallOffset;
		}
		else
		{
			return torchPillarOffset;
		}
	}
	// parent each wall GameObject to LevelObjects transform
	private void OrganizeHierarchy()
	{
		foreach (GameObject current in this.wallList)
		{
			current.transform.parent = sceneryContainer.transform.FindChild("LevelObjects");
		}

	}
	// delete all GameObjects in scene
	private void ClearLevel()
	{
		foreach (GameObject current in this.wallList)
		{
			UnityEngine.Object.Destroy(current);
		}
		// traverse scene hierarchy deleting all gameObjects
	}

	// place braziers in each Room
	private void PlaceBraziers() {
		foreach (Room room in map.roomList) {
			PlaceBrazier(room);
		}
	}

	// given Room r, depending on room dimensions place braziers
	private void PlaceBrazier(Room r) {
		// room to small, place single brazier in center
		if (r.width <= 6 || r.height <= 6) {
			GameObject newBrazier1 = Instantiate (brazierPrefab, new Vector3 (r.x + r.width / 2, 0.0f, r.y + r.height / 2) * this.scaleFactor, brazierPrefab.transform.rotation) as GameObject;
			newBrazier1.transform.parent = sceneryContainer.transform.FindChild("Braziers");
		} else {	// room of adequate size, place four braziers near corners of the room
			float x1 = (float)r.x + brazierOffset;
			float x2 = (float)r.x + (float)r.width - brazierOffset - 1;
			float y1 = (float)r.y + brazierOffset;
			float y2 = (float)r.y + (float)r.height - brazierOffset - 1;
			GameObject newBrazier1 = Instantiate (brazierPrefab, new Vector3 (x1, 0.0f, y1) * this.scaleFactor, brazierPrefab.transform.rotation) as GameObject;
			GameObject newBrazier2 = Instantiate (brazierPrefab, new Vector3 (x1, 0.0f, y2) * this.scaleFactor, brazierPrefab.transform.rotation) as GameObject;
			GameObject newBrazier3 = Instantiate (brazierPrefab, new Vector3 (x2, 0.0f, y1) * this.scaleFactor, brazierPrefab.transform.rotation) as GameObject;
			GameObject newBrazier4 = Instantiate (brazierPrefab, new Vector3 (x2, 0.0f, y2) * this.scaleFactor, brazierPrefab.transform.rotation) as GameObject;
			newBrazier1.transform.parent = sceneryContainer.transform.FindChild("Braziers");
			newBrazier2.transform.parent = sceneryContainer.transform.FindChild("Braziers");
			newBrazier3.transform.parent = sceneryContainer.transform.FindChild("Braziers");
			newBrazier4.transform.parent = sceneryContainer.transform.FindChild("Braziers");

		}
	}

	// place entities such as Player or enemies
	public void PlaceEntities() {
		PlacePlayer ();
		PlaceEnemies ();
	}

	// place the player in the center of the first room (**placeholder)
	public void PlacePlayer()
	{
		Vector3 vector = new Vector3((float)(map.roomList[0].x + map.roomList[0].width / 2), 2f, (float)(map.roomList[0].y + map.roomList[0].height / 2));
		vector *= this.scaleFactor;
		UnityEngine.Object.Instantiate(this.player, vector, Quaternion.identity);
	}

	// place enemies in rooms
	public void PlaceEnemies()
	{
		if (enemyPrefabs.Length > 0) {
			int num = 1;
			while (num < map.roomList.Count && (float)num < this.enemiesPerRoom * (float)(map.roomList.Count - 1)) {
				Vector3 vector = new Vector3 ((float)(map.roomList [num].x + map.roomList [num].width / 2), 0f, (float)(map.roomList [num].y + map.roomList [num].height / 2));
				vector *= this.scaleFactor;
				int num2 = UnityEngine.Random.Range (0, this.enemyPrefabs.Length);
				UnityEngine.Object.Instantiate (this.enemyPrefabs [num2], vector, Quaternion.identity);
				Debug.Log (num2 + ": " + this.enemyPrefabs [num2].name);
				num++;
			}
		}
	}
}
